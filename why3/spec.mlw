(**

  {1 A Why3 Specification for VerifyThis Long Term Challenge 2020 [https://verifythis.github.io/]}

  This is largely inspired from an {h <a
  href="https://formal.iti.kit.edu/~ulbrich/pub/LongTermChallenge.pdf">Event-B
  specification by Matthias Ulbrich</a>}

  This is focus on the formalisation of the key manager component. The
  following operations are permitted:

  getExisting Retrieve an existing key from a database. The email must be associated
to at least one key. There is an indetermistic result if more than one
key is registered for an e-mail address.

requestAdd Request adding an email+key pair that is not yet in the database. A non-existing
confirmation code is returned, but the pair is not added yet to the database.

confirmAdd Once the request has been issued, an email with the code is sent out to the issuer.
If they confirm this code, the addition to the database will take place.

requestDel An existing email+key pair can also be removed from the database by the owner.
When requesting a removal, the pair is not yet removed from the database, but a confirmation code is issued.

confirmDel Once the request has been issued, an email with the code is sent out to the issuer.
If they confirm this code, the deletion from the database will take place.
rerequestDel An open removal request can be reissued, resulting in the same confirmation
code.

*)


module Data

type key
type email
type confirmation_code

constant default_key: key
constant default_email: email


end

module PartialMap

use set.Fset as S

type a
type b

constant default: b

type partial_map =
{ dom: S.fset a;
  assoc: a -> b;
}

constant empty : partial_map = { dom = S.empty; assoc = (fun _ -> default)}

end

module KeyServer

use Data
use option.Option
use set.Fset as S

constant default: (email, key) = (Data.default_email, Data.default_key)

clone PartialMap as P with 
  type a = confirmation_code, 
  type b = (email, key), 
  constant default = default

(*type partial_map 'a 'b =
{ dom: S.fset 'a;
  assoc: 'a -> 'b;
}

constant empty_pm : partial_map 'a 'b

axiom empty_pm_spec: S.is_empty (empty_pm: partial_map 'a 'b).dom
*)
type state = {
  mutable database : S.fset (email, key); (* finite set *)
  mutable openAdds : P.partial_map;
  mutable openDels : P.partial_map;
  }
invariant {
[@noSpuriousDels](* range openDels ⊆ database*)
(forall c. S.mem c openDels.P.dom -> S.mem (openDels.P.assoc c) database)
/\
[@disjointConfirms] (* dom(openDels) ∩ dom(openAdds) = ∅ *)
(forall c. not S.mem c openDels.P.dom \/ not S.mem c openAdds.P.dom)
/\
[@uniqueDels]
(forall x y. S.mem x openDels.P.dom -> S.mem y openDels.P.dom -> x <> y ->
  openDels.P.assoc x <> openDels.P.assoc y)
}
by {database = S.empty; openAdds = P.empty; openDels = P.empty } 

(* Initialization of keyserver *)
let ghost init () : state =
  {
   database = S.empty;
   openAdds = P.empty;
   openDels = P.empty;
  }

(*5.2  Requirements for retrieving a key
Name get 
Parameters
  e:email
Result 
  k:key ∪ {⊥}
Precondition   
  none
Postcondition  
  If k <>  ⊥, then the returned key k is associated with the given email address e in the database.
  k = ⊥ iff there exists no entry for the given address e. 
Effects
  No changes on the database or pending (add or delete) confirmations.
  Please note that this operation is deliberately kept indeterministic. 
  If an e-mail address is associated to more than one key, then the operation may return any key k associated to e *)
let ghost getExisting (s:state) (e:email) : (result:option key)
(* requires { [@guard] email ∈ dom(database)*)
  ensures { [@result] match result with 
            | None -> forall k: key. not (S.mem (e, k) s.database)
            | Some k -> S.mem (e, k) s.database
            end }
= 
  let s' = S.filter s.database (fun ek -> let (e',_) = ek in  e = e') in
  if S.is_empty s' then None else let (e', k) = S.pick s' in 
    assert {e' = e};
    Some k
   

(*



TODO Sylvain

let requestAdd (state:state) (email:email) (key:key) : confirmation_code
  requires {}
grd1: email 7→ key ∈ / database
grd2: conf code ∈ / dom(openAdds) ∪ dom(openDels)

then
act1: openAdds(conf code) := email 7→ key

end



Event confirmAdd hordinaryi =
b
any
conf code IN

where
grd1: conf code ∈ dom(openAdds)

then
act1: openAdds := {conf code} C
− openAdds
act2: database := database ∪ openAdds[{conf code}]

2019.09.10 11:22:56

Page 3 of 4

An Event-B Specification of LongTermChallenge

MACHINE KeyServer

end
TODO Claude
Event requestDel hordinaryi =
b
any
email IN
key IN
conf code OUT

where
grd1: email 7→ key ∈ database
grd2: conf code ∈
/ dom(openAdds) ∪ dom(openDels)
grd3: email 7→ key ∈
/ ran(openDels)

then
act1: openDels(conf code) := email 7→ key
end
Event confirmDel hordinaryi =
b
any
conf code IN

where
grd1: conf code ∈ dom(openDels)

then
act1: openDels := {conf code} C
− openDels
act2: database := database \ openDels[{conf code}]

end
Event rerequestDel hordinaryi =
b
any
email IN
key IN
conf code OUT

where
grd1: email 7→ key ∈ database
grd2: email →
7 key ∈ ran(openDels)
grd3: conf code 7→ (email 7→ key) ∈ openDels

then
skip
end
END

2019.09.10 11:22:56

Page 4 of 4
*)

end

module Implem

use KeyServer as K
clone hashtbl.Hashtbl as Hemail with 
  type key = K.Data.email

clone hashtbl.Hashtbl as Hcc with
  type key = K.Data.confirmation_code

use list.Mem as L

  type concrete_state = {
    database: Hemail.t K.Data.key;
    confirmAdd: Hcc.t K.Data.(email, key);
    confirmDel: Hcc.t K.Data.(email, key);
    ghost model_state: K.state; 
  }
  invariant db_inv { forall e k. 
      K.S.mem (e, k) model_state.K.database <->
      L.mem k (database.Hemail.contents e) }
  invariant add_inv { forall c. let l = confirmAdd.Hcc.contents c in
                       Hcc.List.(match l with
                       | Nil -> not K.S.mem c model_state.K.openAdds.K.P.dom
                       | Cons x Nil -> K.S.mem c model_state.K.openAdds.K.P.dom /\ 
                                       model_state.K.openAdds.K.P.assoc c = x
                       | _ -> false 
                       end)}
  invariant del_inv { forall c. let l = confirmDel.Hcc.contents c in
                       Hcc.List.(match l with
                       | Nil -> not K.S.mem c model_state.K.openDels.K.P.dom
                       | Cons x Nil -> K.S.mem c model_state.K.openDels.K.P.dom /\ 
                                       model_state.K.openDels.K.P.assoc c = x
                       | _ -> false 
                       end)}      
  by { database = Hemail.create 42; confirmAdd = Hcc.create 42;
       confirmDel = Hcc.create 42; model_state = K.init () }

end

