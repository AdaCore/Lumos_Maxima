(**

  {1 A Why3 Specification for VerifyThis Long Term Challenge 2020 [https://verifythis.github.io/]}

  This is largely inspired from an {h <a
  href="https://formal.iti.kit.edu/~ulbrich/pub/LongTermChallenge.pdf">Event-B
  specification by Matthias Ulbrich</a>}

  This is focus on the formalisation of the key manager component. The
  following operations are permitted:

  getExisting Retrieve an existing key from a database. The email must be associated
to at least one key. There is an indetermistic result if more than one
key is registered for an e-mail address.

requestAdd Request adding an email+key pair that is not yet in the database. A non-existing
confirmation code is returned, but the pair is not added yet to the database.

confirmAdd Once the request has been issued, an email with the code is sent out to the issuer.
If they confirm this code, the addition to the database will take place.

requestDel An existing email+key pair can also be removed from the database by the owner.
When requesting a removal, the pair is not yet removed from the database, but a confirmation code is issued.

confirmDel Once the request has been issued, an email with the code is sent out to the issuer.
If they confirm this code, the deletion from the database will take place.
rerequestDel An open removal request can be reissued, resulting in the same confirmation
code.

*)


module Data

use set.Fset as S

type key
type email
type confirmation_code

clone hashtbl.Hashtbl as Hcc with
  type key = confirmation_code

clone hashtbl.Hashtbl as Hemail with
  type key = email

constant default_key: key
constant default_email: email

val compare (k1 k2: key) : bool
  ensures { result <-> k1 = k2 }

val fresh_confirmation_code (s: S.fset confirmation_code) : confirmation_code
  ensures { not S.mem result s }

(* TODO Make a simpler definition (that takes only one set if possible) *)
val fresh_confirmation_code_prog (s: Hcc.t 'a) (s': Hcc.t 'b) : confirmation_code
  ensures { Hcc.([]) s result = Hcc.List.Nil /\
            Hcc.([]) s' result = Hcc.List.Nil }

end

module PartialMap

use set.Fset as S

type a
type b

constant default: b

type partial_map =
{ dom: S.fset a;
  assoc: a -> b;
}

constant empty : partial_map = { dom = S.empty; assoc = (fun _ -> default)}

let ghost function update (p: partial_map) (x: a) (v: b) =
  { dom = S.add x p.dom;
    assoc = (fun x' -> if x' = x then v else p.assoc x') }


end

module KeyServer

use export Data
use option.Option
use set.Fset as S

constant default: (email, key) = (default_email, default_key)

clone PartialMap as P with
  type a = confirmation_code,
  type b = (email, key),
  constant default = default

(*type partial_map 'a 'b =
{ dom: S.fset 'a;
  assoc: 'a -> 'b;
}

constant empty_pm : partial_map 'a 'b

axiom empty_pm_spec: S.is_empty (empty_pm: partial_map 'a 'b).dom
*)
type state = {
  mutable database : S.fset (email, key); (* finite set *)
  mutable openAdds : P.partial_map;
  mutable openDels : P.partial_map;
  }
invariant {
[@noSpuriousDels](* range openDels ⊆ database*)
(forall c. S.mem c openDels.P.dom -> S.mem (openDels.P.assoc c) database)
/\
[@disjointConfirms] (* dom(openDels) ∩ dom(openAdds) = ∅ *)
(forall c. not S.mem c openDels.P.dom \/ not S.mem c openAdds.P.dom)
/\
[@uniqueDels]
(forall x y. S.mem x openDels.P.dom -> S.mem y openDels.P.dom -> x <> y ->
  openDels.P.assoc x <> openDels.P.assoc y)
}
by {database = S.empty; openAdds = P.empty; openDels = P.empty }

(* Initialization of keyserver *)
let ghost function init () : state =
  {
   database = S.empty;
   openAdds = P.empty;
   openDels = P.empty;
  }

predicate isExisting [@inline:trivial] (s: state) (e: email) (k: key) =
  S.mem (e, k) s.database

(**

5.2  Requirements for retrieving a key

Name get

Parameters
  e:email

Result
  k:key ∪ {⊥}

Precondition
  none

Postcondition
  If k <>  ⊥, then the returned key k is associated with the given email address e in the database.
  k = ⊥ iff there exists no entry for the given address e.

Effects
  No changes on the database or pending (add or delete) confirmations.

  Please note that this operation is deliberately kept indeterministic.
  If an e-mail address is associated to more than one key, then the operation may return any key k associated to e
*)
let ghost function getExisting (s:state) (e:email) : (result:option key)
(* requires { [@guard] email ∈ dom(database)*)
  ensures { [@result] match result with
            | None -> forall k: key. not isExisting s e k
            | Some k -> isExisting s e k
            end }
  = let s' = S.filter s.database (fun ek -> let (e',_) = ek in  e = e') in
    if S.is_empty s' then None else let (e', k) = S.pick s' in
       assert {e' = e};
       Some k

(**

{3 5.3 Requirements for adding a key}

{h <ul>
<li>Name

add

<li>Parameters

`e : email`, `k : key`

<li>Result

`c : conf-code`

<li>Precondition

`e` and `k` are well-formed entities. `e` is an e-mail address to which the public key `k` applies.
The tuple `(e, k)` may or may not already be present in the database or a confirmation for
`(e, k)` may be pending.

<li>Postcondition

The confirmation code `c` is unique (a confirmation code is unique iff it was previously not used in a pending add- or del-request) in the system. If `(e, k)` is present in the database, ...
If a request is pending for (e, k), ...

<li>Effects

The database remains unchanged. All pending confirmations are preserved. The only
effect of the operation is that a confirmation request `(c, k, e)` may be added.
}

The actual protocol of the server is more complex. The addition function works as follows. Feel free to
specify and verify the following code
{h <pre>
void verifyingAdd(k: KEY) {
  emails = extractEmailAddressesFromKey(k);
  for( e : emails ) {
    token = add(e, k);
    if (token is valid)
      sendConfirmationEmail(e, token);
  }
}
</pre>}

The randomness of the confirmation code has not been mentioned here, but is an additional optional
requirements.

*)
predicate requestAddSpec [@inline:trivial] (sin sout:state) (e:email) (k:key) (c: confirmation_code)
=
  not S.mem (e, k) sin.database /\
  not S.mem c sin.openAdds.P.dom  /\
  not S.mem c sin.openDels.P.dom /\
  sout.database = sin.database /\
  sout.openAdds = P.update sin.openAdds c (e, k)  /\
  sout.openDels = sin.openDels

let ghost requestAdd (s:state) (e:email) (k:key) : option confirmation_code
  requires { true }
  ensures { match result with
            | None -> S.mem (e,k) s.database
            | Some c -> requestAddSpec (old s) s e k c
            end }
  = if S.mem (e,k) s.database then
      None
    else
      let c = fresh_confirmation_code (S.union s.openAdds.P.dom s.openDels.P.dom) in
      s.openAdds <- P.update s.openAdds c (e, k);
      Some c

(*

Event confirmAdd hordinaryi =
b
any
conf code IN

where
grd1: conf code ∈ dom(openAdds)

then
act1: openAdds := {conf code} C
− openAdds
act2: database := database ∪ openAdds[{conf code}]

2019.09.10 11:22:56

Page 3 of 4

An Event-B Specification of LongTermChallenge

MACHINE KeyServer

end
TODO Claude
Event requestDel hordinaryi =
b
any
email IN
key IN
conf code OUT

where
grd1: email 7→ key ∈ database
grd2: conf code ∈
/ dom(openAdds) ∪ dom(openDels)
grd3: email 7→ key ∈
/ ran(openDels)

then
act1: openDels(conf code) := email 7→ key
end
Event confirmDel hordinaryi =
b
any
conf code IN

where
grd1: conf code ∈ dom(openDels)

then
act1: openDels := {conf code} C
− openDels
act2: database := database \ openDels[{conf code}]

end
Event rerequestDel hordinaryi =
b
any
email IN
key IN
conf code OUT

where
grd1: email 7→ key ∈ database
grd2: email →
7 key ∈ ran(openDels)
grd3: conf code 7→ (email 7→ key) ∈ openDels

then
skip
end
END

2019.09.10 11:22:56

Page 4 of 4
*)

end

module Implem

use option.Option

use KeyServer as K
use list.ListRich as L
use list.Quant as Lq

  type concrete_state = {
    database: K.Hemail.t K.key;
    confirmAdd: K.Hcc.t K.(email, key);
    confirmDel: K.Hcc.t K.(email, key);
    ghost model_state: K.state;
  }
  invariant db_inv { forall e k.
      K.S.mem (e, k) model_state.K.database <->
      L.mem k (database.K.Hemail.contents e) }
  invariant add_inv { forall c. let l = confirmAdd.K.Hcc.contents c in
                       K.Hcc.List.(match l with
                       | Nil -> not K.S.mem c model_state.K.openAdds.K.P.dom
                       | Cons x Nil -> K.S.mem c model_state.K.openAdds.K.P.dom /\
                                       model_state.K.openAdds.K.P.assoc c = x
                       | _ -> false
                       end)}
  invariant del_inv { forall c. let l = confirmDel.K.Hcc.contents c in
                       K.Hcc.List.(match l with
                       | Nil -> not K.S.mem c model_state.K.openDels.K.P.dom
                       | Cons x Nil -> K.S.mem c model_state.K.openDels.K.P.dom /\
                                       model_state.K.openDels.K.P.assoc c = x
                       | _ -> false
                       end)}
  by { database = K.Hemail.create 42; confirmAdd = K.Hcc.create 42;
       confirmDel = K.Hcc.create 42; model_state = K.init () }

let init () : concrete_state
  ensures abs_state { result.model_state = K.init () }
  =
    { database = K.Hemail.create 42; confirmAdd = K.Hcc.create 42;
      confirmDel = K.Hcc.create 42; model_state = K.init () }

exception Not_found

let get (s: concrete_state) (e:K.email) : (result: K.key)
  ensures { K.isExisting s.model_state e result  }
  raises  { Not_found -> forall k. not K.isExisting s.model_state e k}
=
  let l = K.Hemail.find_all s.database e in
  K.Hemail.List.(match l with
  | Nil -> raise Not_found
  | Cons k _ ->
      assert { K.S.mem (e, k) s.model_state.K.database };
      k
  end)

exception AlreadyInDb

let add (s: concrete_state) (e: K.email) (k: K.key) : K.confirmation_code
  requires { true }
  ensures  { K.requestAddSpec (old s.model_state) s.model_state e k result }
  raises   { AlreadyInDb -> K.S.mem (e,k) s.model_state.K.database }
=
  let l = K.Hemail.find_all s.database e in
  if Lq.mem (fun k1 k2 -> K.compare k1 k2) k l then
    raise AlreadyInDb
  else
    let c = K.fresh_confirmation_code_prog s.confirmAdd s.confirmDel in
    K.Hcc.add s.confirmAdd c (e, k);
    c

(*
predicate requestAddSpec [@inline:trivial] (sin sout:state) (e:email) (k:key) (c: confirmation_code)
=
  not S.mem (e, k) sin.database /\
  not S.mem c sin.openAdds.P.dom  /\
  not S.mem c sin.openDels.P.dom /\
  sout.database = sin.database /\
  sout.openAdds = P.update sin.openAdds c (e, k)  /\
  sout.openDels = sin.openDels

let ghost requestAdd (s:state) (e:email) (k:key) : option confirmation_code
  requires { true }
  ensures { match result with
            | None -> S.mem (e,k) s.database
            | Some c -> requestAddSpec (old s) s e k c
            end }
  = if S.mem (e,k) s.database then
      None
    else
      let c = Data.fresh_confirmation_code (S.union s.openAdds.P.dom s.openDels.P.dom) in
      s.openAdds <- P.update s.openAdds c (e, k);
      Some c
*)

end
